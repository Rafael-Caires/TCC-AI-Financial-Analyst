/**
 * Test Runner - Executa toda a suite de testes
 * 
 * Este arquivo orquestra a execu√ß√£o de todos os testes do sistema,
 * incluindo testes unit√°rios, integra√ß√£o e end-to-end.
 * 
 * Autor: Rafael Lima Caires
 * Data: Dezembro 2024
 */

// Importa todos os m√≥dulos de teste
const { setupTestEnvironment } = require('./setup');

// Setup inicial
setupTestEnvironment();

// Importa classes de teste
let TestAIAnalysis, AIAnalysisIntegrationTests;
let TestRecommendations, RecommendationsPerformanceTests, RecommendationsIntegrationTests;
let TestPortfolio, PortfolioIntegrationTests;
let EndToEndTests;

try {
  ({ TestAIAnalysis, AIAnalysisIntegrationTests } = require('./test-aianalysis'));
  ({ TestRecommendations, RecommendationsPerformanceTests, RecommendationsIntegrationTests } = require('./test-recommendations'));
  ({ TestPortfolio, PortfolioIntegrationTests } = require('./test-portfolio'));
  ({ EndToEndTests } = require('./test-e2e'));
} catch (error) {
  console.warn('‚ö†Ô∏è Alguns m√≥dulos de teste podem n√£o estar dispon√≠veis:', error.message);
}

class TestRunner {
  
  constructor() {
    this.results = {
      unit: {},
      integration: {},
      e2e: {},
      performance: {}
    };
  }
  
  /**
   * Executa testes unit√°rios de todos os componentes
   */
  async runUnitTests() {
    console.log('\nüß™ EXECUTANDO TESTES UNIT√ÅRIOS');
    console.log('==============================\n');
    
    const unitResults = {};
    
    // Testes do AIAnalysis
    if (TestAIAnalysis) {
      console.log('ü§ñ Testando componente AIAnalysis...');
      try {
        unitResults.aiAnalysis = await TestAIAnalysis.runAllTests();
      } catch (error) {
        console.error('‚ùå Erro nos testes do AIAnalysis:', error.message);
        unitResults.aiAnalysis = { successRate: 0, error: error.message };
      }
    }
    
    // Testes do Recommendations
    if (TestRecommendations) {
      console.log('\nüí° Testando componente Recommendations...');
      try {
        unitResults.recommendations = await TestRecommendations.runAllTests();
      } catch (error) {
        console.error('‚ùå Erro nos testes do Recommendations:', error.message);
        unitResults.recommendations = { successRate: 0, error: error.message };
      }
    }
    
    // Testes do Portfolio
    if (TestPortfolio) {
      console.log('\nüíº Testando componente Portfolio...');
      try {
        unitResults.portfolio = await TestPortfolio.runAllTests();
      } catch (error) {
        console.error('‚ùå Erro nos testes do Portfolio:', error.message);
        unitResults.portfolio = { successRate: 0, error: error.message };
      }
    }
    
    this.results.unit = unitResults;
    return unitResults;
  }
  
  /**
   * Executa testes de integra√ß√£o
   */
  async runIntegrationTests() {
    console.log('\nüîß EXECUTANDO TESTES DE INTEGRA√á√ÉO');
    console.log('==================================\n');
    
    const integrationResults = {};
    
    // Integra√ß√£o AIAnalysis
    if (AIAnalysisIntegrationTests) {
      console.log('ü§ñ Testando integra√ß√£o do AIAnalysis...');
      try {
        integrationResults.aiAnalysis = await AIAnalysisIntegrationTests.runIntegrationTests();
      } catch (error) {
        console.error('‚ùå Erro na integra√ß√£o do AIAnalysis:', error.message);
        integrationResults.aiAnalysis = { integrationPassed: false, error: error.message };
      }
    }
    
    // Integra√ß√£o Recommendations
    if (RecommendationsIntegrationTests) {
      console.log('\nüí° Testando integra√ß√£o do Recommendations...');
      try {
        integrationResults.recommendations = await RecommendationsIntegrationTests.runIntegrationTests();
      } catch (error) {
        console.error('‚ùå Erro na integra√ß√£o do Recommendations:', error.message);
        integrationResults.recommendations = { integrationPassed: false, error: error.message };
      }
    }
    
    // Integra√ß√£o Portfolio
    if (PortfolioIntegrationTests) {
      console.log('\nüíº Testando integra√ß√£o do Portfolio...');
      try {
        integrationResults.portfolio = await PortfolioIntegrationTests.runIntegrationTests();
      } catch (error) {
        console.error('‚ùå Erro na integra√ß√£o do Portfolio:', error.message);
        integrationResults.portfolio = { integrationPassed: false, error: error.message };
      }
    }
    
    this.results.integration = integrationResults;
    return integrationResults;
  }
  
  /**
   * Executa testes de performance
   */
  async runPerformanceTests() {
    console.log('\n‚ö° EXECUTANDO TESTES DE PERFORMANCE');
    console.log('==================================\n');
    
    const performanceResults = {};
    
    // Performance Recommendations
    if (RecommendationsPerformanceTests) {
      console.log('üí° Testando performance do Recommendations...');
      try {
        performanceResults.recommendations = await RecommendationsPerformanceTests.runPerformanceTests();
      } catch (error) {
        console.error('‚ùå Erro na performance do Recommendations:', error.message);
        performanceResults.recommendations = { performancePassed: false, error: error.message };
      }
    }
    
    this.results.performance = performanceResults;
    return performanceResults;
  }
  
  /**
   * Executa testes end-to-end
   */
  async runE2ETests() {
    console.log('\nüé¨ EXECUTANDO TESTES END-TO-END');
    console.log('==============================\n');
    
    let e2eResults = {};
    
    if (EndToEndTests) {
      console.log('üåê Executando testes de sistema completo...');
      try {
        e2eResults = await EndToEndTests.runAllE2ETests();
      } catch (error) {
        console.error('‚ùå Erro nos testes E2E:', error.message);
        e2eResults = { overallSuccess: false, successRate: 0, error: error.message };
      }
    }
    
    this.results.e2e = e2eResults;
    return e2eResults;
  }
  
  /**
   * Gera relat√≥rio final consolidado
   */
  generateFinalReport() {
    console.log('\nüìä RELAT√ìRIO FINAL DOS TESTES');
    console.log('=============================\n');
    
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        unit: this.calculateUnitTestsSummary(),
        integration: this.calculateIntegrationSummary(),
        performance: this.calculatePerformanceSummary(),
        e2e: this.calculateE2ESummary()
      },
      details: this.results
    };
    
    // Exibe sum√°rio executivo
    console.log('üéØ SUM√ÅRIO EXECUTIVO');
    console.log('===================');
    console.log(`üìà Testes Unit√°rios: ${report.summary.unit.averageSuccess.toFixed(1)}%`);
    console.log(`üîß Testes de Integra√ß√£o: ${report.summary.integration.overallSuccess ? 'PASSOU' : 'FALHOU'}`);
    console.log(`‚ö° Testes de Performance: ${report.summary.performance.overallSuccess ? 'PASSOU' : 'FALHOU'}`);
    console.log(`üåê Testes End-to-End: ${report.summary.e2e.success ? 'PASSOU' : 'FALHOU'} (${report.summary.e2e.successRate.toFixed(1)}%)`);
    
    // Determina status geral
    const overallQuality = this.determineOverallQuality(report.summary);
    
    console.log('\nüéñÔ∏è QUALIDADE GERAL DO SISTEMA');
    console.log('=============================');
    console.log(`Status: ${overallQuality.status}`);
    console.log(`Nota: ${overallQuality.grade}`);
    console.log(`Descri√ß√£o: ${overallQuality.description}`);
    
    // Recomenda√ß√µes
    console.log('\nüí° RECOMENDA√á√ïES');
    console.log('================');
    overallQuality.recommendations.forEach((rec, index) => {
      console.log(`${index + 1}. ${rec}`);
    });
    
    return report;
  }
  
  /**
   * Calcula sum√°rio dos testes unit√°rios
   */
  calculateUnitTestsSummary() {
    const unitResults = this.results.unit;
    const components = Object.keys(unitResults);
    
    if (components.length === 0) {
      return { averageSuccess: 0, componentsCount: 0 };
    }
    
    const totalSuccess = components.reduce((sum, component) => {
      return sum + (unitResults[component].successRate || 0);
    }, 0);
    
    return {
      averageSuccess: totalSuccess / components.length,
      componentsCount: components.length,
      details: unitResults
    };
  }
  
  /**
   * Calcula sum√°rio dos testes de integra√ß√£o
   */
  calculateIntegrationSummary() {
    const integrationResults = this.results.integration;
    const components = Object.keys(integrationResults);
    
    const passedComponents = components.filter(component => 
      integrationResults[component].integrationPassed
    ).length;
    
    return {
      overallSuccess: passedComponents === components.length && components.length > 0,
      passedComponents,
      totalComponents: components.length,
      details: integrationResults
    };
  }
  
  /**
   * Calcula sum√°rio dos testes de performance
   */
  calculatePerformanceSummary() {
    const performanceResults = this.results.performance;
    const components = Object.keys(performanceResults);
    
    const passedComponents = components.filter(component => 
      performanceResults[component].performancePassed
    ).length;
    
    return {
      overallSuccess: passedComponents === components.length && components.length > 0,
      passedComponents,
      totalComponents: components.length,
      details: performanceResults
    };
  }
  
  /**
   * Calcula sum√°rio dos testes E2E
   */
  calculateE2ESummary() {
    const e2eResults = this.results.e2e;
    
    return {
      success: e2eResults.overallSuccess || false,
      successRate: e2eResults.successRate || 0,
      totalTests: e2eResults.total || 0,
      passedTests: e2eResults.passed || 0,
      details: e2eResults
    };
  }
  
  /**
   * Determina qualidade geral do sistema
   */
  determineOverallQuality(summary) {
    const unitScore = summary.unit.averageSuccess;
    const integrationScore = summary.integration.overallSuccess ? 100 : 0;
    const performanceScore = summary.performance.overallSuccess ? 100 : 0;
    const e2eScore = summary.e2e.successRate;
    
    // Calcula nota ponderada
    const weightedScore = (
      unitScore * 0.35 +           // 35% - Testes unit√°rios
      integrationScore * 0.25 +    // 25% - Testes de integra√ß√£o
      performanceScore * 0.15 +    // 15% - Testes de performance
      e2eScore * 0.25             // 25% - Testes E2E
    );
    
    let status, grade, description, recommendations;
    
    if (weightedScore >= 90) {
      status = 'üü¢ EXCELENTE';
      grade = 'A+';
      description = 'Sistema de alt√≠ssima qualidade, pronto para produ√ß√£o.';
      recommendations = [
        'Sistema aprovado para produ√ß√£o',
        'Manter rotina de testes regulares',
        'Considerar implementar testes automatizados em CI/CD'
      ];
    } else if (weightedScore >= 80) {
      status = 'üü¢ BOM';
      grade = 'A';
      description = 'Sistema de boa qualidade com pequenos pontos de melhoria.';
      recommendations = [
        'Sistema aprovado para produ√ß√£o',
        'Corrigir pontos menores identificados',
        'Melhorar cobertura de testes onde necess√°rio'
      ];
    } else if (weightedScore >= 70) {
      status = 'üü° SATISFAT√ìRIO';
      grade = 'B';
      description = 'Sistema funcional mas necessita melhorias importantes.';
      recommendations = [
        'Implementar melhorias antes da produ√ß√£o',
        'Focar nos testes que falharam',
        'Revisar arquitetura dos componentes cr√≠ticos'
      ];
    } else if (weightedScore >= 60) {
      status = 'üü† PRECISA MELHORAR';
      grade = 'C';
      description = 'Sistema com problemas significativos que impedem produ√ß√£o.';
      recommendations = [
        'N√ÉO aprovar para produ√ß√£o',
        'Implementar corre√ß√µes extensivas',
        'Revisar design e arquitetura do sistema',
        'Executar nova rodada de testes ap√≥s corre√ß√µes'
      ];
    } else {
      status = 'üî¥ CR√çTICO';
      grade = 'D';
      description = 'Sistema com falhas graves que impedem uso seguro.';
      recommendations = [
        'SISTEMA REPROVADO para produ√ß√£o',
        'Revisar completamente a implementa√ß√£o',
        'Considerar refatora√ß√£o major',
        'Implementar plano de corre√ß√£o abrangente'
      ];
    }
    
    return {
      status,
      grade,
      description,
      score: weightedScore,
      recommendations
    };
  }
  
  /**
   * Executa todos os testes em sequ√™ncia
   */
  async runAllTests() {
    console.log('\nüöÄ INICIANDO EXECU√á√ÉO COMPLETA DOS TESTES');
    console.log('=========================================');
    console.log(`‚è∞ In√≠cio: ${new Date().toLocaleString()}\n`);
    
    const startTime = performance.now();
    
    try {
      // 1. Testes unit√°rios
      await this.runUnitTests();
      
      // 2. Testes de integra√ß√£o
      await this.runIntegrationTests();
      
      // 3. Testes de performance
      await this.runPerformanceTests();
      
      // 4. Testes end-to-end
      await this.runE2ETests();
      
      // 5. Relat√≥rio final
      const report = this.generateFinalReport();
      
      const endTime = performance.now();
      const totalDuration = ((endTime - startTime) / 1000).toFixed(2);
      
      console.log(`\n‚è±Ô∏è TEMPO TOTAL DE EXECU√á√ÉO: ${totalDuration} segundos`);
      console.log(`üèÅ Fim: ${new Date().toLocaleString()}`);
      
      return report;
      
    } catch (error) {
      console.error('\nüí• ERRO CR√çTICO NA EXECU√á√ÉO DOS TESTES');
      console.error('=====================================');
      console.error('Erro:', error.message);
      console.error('Stack:', error.stack);
      
      return {
        error: true,
        message: error.message,
        results: this.results
      };
    }
  }
}

// Fun√ß√£o para executar testes se chamado diretamente
async function main() {
  const runner = new TestRunner();
  const results = await runner.runAllTests();
  
  // Salva relat√≥rio em arquivo se poss√≠vel
  if (typeof require !== 'undefined') {
    const fs = require('fs');
    const path = require('path');
    
    try {
      const reportPath = path.join(__dirname, 'test-report.json');
      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
      console.log(`\nüìù Relat√≥rio salvo em: ${reportPath}`);
    } catch (error) {
      console.warn('‚ö†Ô∏è N√£o foi poss√≠vel salvar o relat√≥rio:', error.message);
    }
  }
  
  return results;
}

// Exporta classes e fun√ß√µes
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    TestRunner,
    main
  };
}

// Executa se chamado diretamente
if (typeof require !== 'undefined' && require.main === module) {
  main().then(() => {
    console.log('\n‚ú® Execu√ß√£o dos testes finalizada!');
    process.exit(0);
  }).catch(error => {
    console.error('\nüí• Erro fatal:', error);
    process.exit(1);
  });
}
