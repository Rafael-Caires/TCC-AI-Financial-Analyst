/**
 * Testes para o Componente Recommendations
 * 
 * Este arquivo testa todas as funcionalidades do componente Recommendations,
 * incluindo sistema de recomenda√ß√µes, filtros, visualiza√ß√µes e interatividade.
 * 
 * Autor: Rafael Lima Caires
 * Data: Dezembro 2024
 */

// Importa setup de testes
const { 
  setupTestEnvironment, 
  TestUtils, 
  mockRender, 
  mockScreen, 
  mockFireEvent, 
  mockWaitFor 
} = require('./setup');

// Setup do ambiente de teste
setupTestEnvironment();

// Mock do componente Recommendations
const MockRecommendations = ({ filters = {}, sortBy = 'score' }) => {
  return {
    props: { filters, sortBy },
    state: {
      recommendations: [],
      loading: false,
      activeTab: 'all'
    },
    render: () => ({
      textContent: 'Recommendations Component',
      querySelector: (selector) => ({ textContent: 'Mock element' })
    })
  };
};

class TestRecommendations {
  
  /**
   * Testa renderiza√ß√£o b√°sica do componente
   */
  static testBasicRendering() {
    console.log('üß™ Testando renderiza√ß√£o b√°sica do Recommendations...');
    
    const component = new MockRecommendations({});
    const rendered = component.render();
    
    // Valida que o componente renderiza
    if (!rendered || !rendered.textContent) {
      throw new Error('Componente Recommendations n√£o renderizou corretamente');
    }
    
    console.log('‚úÖ Renderiza√ß√£o b√°sica OK');
    return true;
  }
  
  /**
   * Testa carregamento de recomenda√ß√µes da API
   */
  static async testRecommendationsLoading() {
    console.log('üß™ Testando carregamento de recomenda√ß√µes...');
    
    try {
      const response = await fetch('/api/recommendations/advanced');
      const data = await response.json();
      
      // Valida estrutura da resposta
      if (!data.success || !data.data) {
        throw new Error('Resposta da API inv√°lida');
      }
      
      const recommendations = data.data.recommendations;
      
      // Valida estrutura das recomenda√ß√µes
      if (!Array.isArray(recommendations) || recommendations.length === 0) {
        console.warn('Nenhuma recomenda√ß√£o encontrada');
        return true; // N√£o √© erro, apenas aviso
      }
      
      // Valida estrutura de cada recomenda√ß√£o
      const firstRec = recommendations[0];
      const requiredFields = ['symbol', 'score', 'action', 'confidence'];
      
      for (const field of requiredFields) {
        if (!(field in firstRec)) {
          console.warn(`Campo '${field}' n√£o encontrado na recomenda√ß√£o`);
        }
      }
      
      console.log(`‚úÖ Carregamento de recomenda√ß√µes OK - ${recommendations.length} encontradas`);
      return true;
      
    } catch (error) {
      console.error('‚ùå Erro no carregamento de recomenda√ß√µes:', error.message);
      return false;
    }
  }
  
  /**
   * Testa sistema de filtragem de recomenda√ß√µes
   */
  static testRecommendationFilters() {
    console.log('üß™ Testando filtros de recomenda√ß√µes...');
    
    const mockRecommendations = TestUtils.createMockRecommendations();
    let filtersWorking = 0;
    const totalFilters = 4;
    
    try {
      // Filtro por a√ß√£o (buy, sell, hold)
      const buyRecommendations = mockRecommendations.filter(r => r.action === 'BUY');
      if (buyRecommendations.length > 0) {
        console.log('üéØ Filtro por a√ß√£o (BUY): OK');
        filtersWorking++;
      }
      
      // Filtro por score m√≠nimo
      const highScoreRecs = mockRecommendations.filter(r => r.score >= 0.7);
      if (highScoreRecs.length >= 0) {
        console.log('üìä Filtro por score: OK');
        filtersWorking++;
      }
      
      // Filtro por setor
      const sectorFilter = mockRecommendations.filter(r => 
        r.sector && r.sector === 'FINANCEIRO'
      );
      if (sectorFilter.length >= 0) {
        console.log('üè¢ Filtro por setor: OK');
        filtersWorking++;
      }
      
      // Filtro por risco
      const lowRiskRecs = mockRecommendations.filter(r => r.risk_level === 'BAIXO');
      if (lowRiskRecs.length >= 0) {
        console.log('‚ö†Ô∏è Filtro por risco: OK');
        filtersWorking++;
      }
      
    } catch (error) {
      console.error('‚ùå Erro nos filtros:', error.message);
    }
    
    const success = filtersWorking === totalFilters;
    console.log(`${success ? '‚úÖ' : '‚ö†Ô∏è'} Filtros de recomenda√ß√£o: ${filtersWorking}/${totalFilters}`);
    
    return success;
  }
  
  /**
   * Testa funcionalidade das tabs (Todas, Compra, Venda)
   */
  static testTabFunctionality() {
    console.log('üß™ Testando funcionalidade das tabs...');
    
    const tabs = ['all', 'buy', 'sell'];
    let tabsWorking = 0;
    
    tabs.forEach(tab => {
      try {
        const component = new MockRecommendations({});
        component.state.activeTab = tab;
        
        // Simula mudan√ßa de tab
        const mockRecommendations = TestUtils.createMockRecommendations();
        
        let filteredRecs;
        switch (tab) {
          case 'buy':
            filteredRecs = mockRecommendations.filter(r => r.action === 'BUY');
            break;
          case 'sell':
            filteredRecs = mockRecommendations.filter(r => r.action === 'SELL');
            break;
          default:
            filteredRecs = mockRecommendations;
        }
        
        if (Array.isArray(filteredRecs)) {
          console.log(`üìë Tab '${tab}': OK (${filteredRecs.length} recomenda√ß√µes)`);
          tabsWorking++;
        }
        
      } catch (error) {
        console.error(`‚ùå Erro na tab ${tab}:`, error.message);
      }
    });
    
    const success = tabsWorking === tabs.length;
    console.log(`${success ? '‚úÖ' : '‚ö†Ô∏è'} Funcionalidade das tabs: ${tabsWorking}/${tabs.length}`);
    
    return success;
  }
  
  /**
   * Testa ordena√ß√£o das recomenda√ß√µes
   */
  static testRecommendationSorting() {
    console.log('üß™ Testando ordena√ß√£o das recomenda√ß√µes...');
    
    const mockRecommendations = TestUtils.createMockRecommendations();
    let sortingTests = 0;
    const totalSorts = 3;
    
    try {
      // Ordena√ß√£o por score (descendente)
      const sortedByScore = [...mockRecommendations].sort((a, b) => b.score - a.score);
      if (sortedByScore[0].score >= sortedByScore[sortedByScore.length - 1].score) {
        console.log('üìä Ordena√ß√£o por score: OK');
        sortingTests++;
      }
      
      // Ordena√ß√£o por s√≠mbolo (alfab√©tica)
      const sortedBySymbol = [...mockRecommendations].sort((a, b) => 
        a.symbol.localeCompare(b.symbol)
      );
      if (sortedBySymbol[0].symbol <= sortedBySymbol[1]?.symbol || sortedBySymbol.length === 1) {
        console.log('üî§ Ordena√ß√£o por s√≠mbolo: OK');
        sortingTests++;
      }
      
      // Ordena√ß√£o por potencial de retorno
      const sortedByReturn = [...mockRecommendations].sort((a, b) => 
        (b.expected_return || 0) - (a.expected_return || 0)
      );
      if (sortedByReturn.length > 0) {
        console.log('üìà Ordena√ß√£o por retorno: OK');
        sortingTests++;
      }
      
    } catch (error) {
      console.error('‚ùå Erro na ordena√ß√£o:', error.message);
    }
    
    const success = sortingTests === totalSorts;
    console.log(`${success ? '‚úÖ' : '‚ö†Ô∏è'} Ordena√ß√£o: ${sortingTests}/${totalSorts}`);
    
    return success;
  }
  
  /**
   * Testa detalhes expandidos das recomenda√ß√µes
   */
  static testRecommendationDetails() {
    console.log('üß™ Testando detalhes das recomenda√ß√µes...');
    
    const mockRecommendation = TestUtils.createMockRecommendations()[0];
    let detailsWorking = 0;
    const totalDetails = 5;
    
    try {
      // Verifica an√°lise t√©cnica
      if (mockRecommendation.technical_analysis) {
        console.log('üìä An√°lise t√©cnica: OK');
        detailsWorking++;
      }
      
      // Verifica an√°lise fundamentalista
      if (mockRecommendation.fundamental_analysis) {
        console.log('üìã An√°lise fundamentalista: OK');
        detailsWorking++;
      }
      
      // Verifica m√©tricas de risco
      if (mockRecommendation.risk_metrics) {
        console.log('‚ö†Ô∏è M√©tricas de risco: OK');
        detailsWorking++;
      }
      
      // Verifica pre√ßo alvo
      if (mockRecommendation.target_price) {
        console.log('üéØ Pre√ßo alvo: OK');
        detailsWorking++;
      }
      
      // Verifica justificativa
      if (mockRecommendation.reasoning) {
        console.log('üí≠ Justificativa: OK');
        detailsWorking++;
      }
      
    } catch (error) {
      console.error('‚ùå Erro nos detalhes:', error.message);
    }
    
    const success = detailsWorking >= 3; // Pelo menos 60% dos detalhes
    console.log(`${success ? '‚úÖ' : '‚ö†Ô∏è'} Detalhes da recomenda√ß√£o: ${detailsWorking}/${totalDetails}`);
    
    return success;
  }
  
  /**
   * Testa tratamento de estados de carregamento
   */
  static testLoadingStates() {
    console.log('üß™ Testando estados de carregamento...');
    
    try {
      const component = new MockRecommendations({});
      
      // Estado de carregamento
      component.state.loading = true;
      component.state.recommendations = [];
      
      // Verifica se o componente mostra loading
      console.log('‚è≥ Estado de carregamento: OK');
      
      // Estado vazio
      component.state.loading = false;
      component.state.recommendations = [];
      
      console.log('üì≠ Estado vazio: OK');
      
      // Estado com dados
      component.state.loading = false;
      component.state.recommendations = TestUtils.createMockRecommendations();
      
      console.log('üìä Estado com dados: OK');
      
      console.log('‚úÖ Estados de carregamento OK');
      return true;
      
    } catch (error) {
      console.error('‚ùå Erro nos estados de carregamento:', error.message);
      return false;
    }
  }
  
  /**
   * Testa intera√ß√µes do usu√°rio
   */
  static async testUserInteractions() {
    console.log('üß™ Testando intera√ß√µes do usu√°rio...');
    
    try {
      // Simula clique em tab
      await TestUtils.simulateUserInteraction.clickButton('buy-tab');
      
      // Simula mudan√ßa de filtro
      await TestUtils.simulateUserInteraction.selectOption('sector-filter', 'FINANCEIRO');
      
      // Simula ordena√ß√£o
      await TestUtils.simulateUserInteraction.selectOption('sort-select', 'score');
      
      // Simula expans√£o de detalhes
      await TestUtils.simulateUserInteraction.clickButton('expand-details-PETR4');
      
      console.log('‚úÖ Intera√ß√µes do usu√°rio OK');
      return true;
      
    } catch (error) {
      console.error('‚ùå Erro nas intera√ß√µes:', error.message);
      return false;
    }
  }
  
  /**
   * Testa responsividade das cards de recomenda√ß√£o
   */
  static testResponsiveCards() {
    console.log('üß™ Testando responsividade das cards...');
    
    const viewports = [
      { width: 320, cols: 1 },
      { width: 768, cols: 2 },
      { width: 1024, cols: 3 },
      { width: 1920, cols: 4 }
    ];
    
    let responsiveTests = 0;
    
    viewports.forEach(viewport => {
      try {
        // Simula viewport
        Object.defineProperty(window, 'innerWidth', {
          writable: true,
          configurable: true,
          value: viewport.width
        });
        
        // Verifica layout das cards
        const expectedCols = viewport.cols;
        console.log(`üí≥ Cards em ${viewport.width}px: ${expectedCols} colunas esperadas`);
        
        responsiveTests++;
        
      } catch (error) {
        console.error(`‚ùå Erro na responsividade ${viewport.width}px:`, error.message);
      }
    });
    
    const success = responsiveTests === viewports.length;
    console.log(`${success ? '‚úÖ' : '‚ö†Ô∏è'} Cards responsivas: ${responsiveTests}/${viewports.length}`);
    
    return success;
  }
  
  /**
   * Executa todos os testes do componente Recommendations
   */
  static async runAllTests() {
    console.log('\nüöÄ Iniciando testes do componente Recommendations...\n');
    
    const tests = [
      { name: 'Renderiza√ß√£o B√°sica', test: () => this.testBasicRendering() },
      { name: 'Carregamento de Recomenda√ß√µes', test: () => this.testRecommendationsLoading() },
      { name: 'Filtros de Recomenda√ß√£o', test: () => this.testRecommendationFilters() },
      { name: 'Funcionalidade das Tabs', test: () => this.testTabFunctionality() },
      { name: 'Ordena√ß√£o de Recomenda√ß√µes', test: () => this.testRecommendationSorting() },
      { name: 'Detalhes das Recomenda√ß√µes', test: () => this.testRecommendationDetails() },
      { name: 'Estados de Carregamento', test: () => this.testLoadingStates() },
      { name: 'Intera√ß√µes do Usu√°rio', test: () => this.testUserInteractions() },
      { name: 'Cards Responsivas', test: () => this.testResponsiveCards() }
    ];
    
    const results = [];
    
    for (const { name, test } of tests) {
      try {
        const result = await test();
        results.push({ name, passed: result, error: null });
      } catch (error) {
        results.push({ name, passed: false, error: error.message });
        console.error(`‚ùå ${name} falhou:`, error.message);
      }
    }
    
    // Sum√°rio dos resultados
    console.log('\nüìä SUM√ÅRIO DOS TESTES - Recommendations');
    console.log('=====================================');
    
    const passed = results.filter(r => r.passed).length;
    const failed = results.filter(r => !r.passed).length;
    
    results.forEach(result => {
      const icon = result.passed ? '‚úÖ' : '‚ùå';
      console.log(`${icon} ${result.name}`);
      if (result.error) {
        console.log(`   ‚îî‚îÄ Erro: ${result.error}`);
      }
    });
    
    console.log(`\nüìà Resultados: ${passed}/${tests.length} testes passaram`);
    console.log(`üìä Taxa de sucesso: ${Math.round((passed / tests.length) * 100)}%\n`);
    
    return {
      total: tests.length,
      passed,
      failed,
      results,
      successRate: (passed / tests.length) * 100
    };
  }
}

// Classe para testes de performance das recomenda√ß√µes
class RecommendationsPerformanceTests {
  
  static async testRecommendationPerformance() {
    console.log('‚ö° Testando performance das recomenda√ß√µes...');
    
    try {
      const startTime = performance.now();
      
      // Simula carregamento de muitas recomenda√ß√µes
      const mockRecommendations = [];
      for (let i = 0; i < 100; i++) {
        mockRecommendations.push(...TestUtils.createMockRecommendations());
      }
      
      // Simula filtros e ordena√ß√£o
      const filtered = mockRecommendations
        .filter(r => r.score >= 0.5)
        .sort((a, b) => b.score - a.score);
      
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      const isPerformant = duration < 100; // Menos de 100ms
      
      console.log(`‚ö° Performance: ${duration.toFixed(2)}ms (${isPerformant ? 'OK' : 'LENTO'})`);
      
      return isPerformant;
      
    } catch (error) {
      console.error('‚ùå Erro no teste de performance:', error.message);
      return false;
    }
  }
  
  static async runPerformanceTests() {
    console.log('\n‚ö° Executando testes de performance - Recommendations...\n');
    
    const performanceTest = await this.testRecommendationPerformance();
    
    console.log('\nüìä RESULTADOS DE PERFORMANCE');
    console.log('=============================');
    console.log(`${performanceTest ? '‚úÖ' : '‚ùå'} Performance das recomenda√ß√µes`);
    
    return { performancePassed: performanceTest };
  }
}

// Classe para testes de integra√ß√£o
class RecommendationsIntegrationTests {
  
  static async testRecommendationWorkflow() {
    console.log('üîÑ Testando workflow de recomenda√ß√µes...');
    
    try {
      // 1. Carrega recomenda√ß√µes
      await TestRecommendations.testRecommendationsLoading();
      
      // 2. Aplica filtros
      await TestUtils.simulateUserInteraction.selectOption('action-filter', 'BUY');
      
      // 3. Ordena resultados
      await TestUtils.simulateUserInteraction.selectOption('sort-select', 'score');
      
      // 4. Expande detalhes
      await TestUtils.simulateUserInteraction.clickButton('expand-details');
      
      // 5. Muda de tab
      await TestUtils.simulateUserInteraction.clickButton('sell-tab');
      
      console.log('‚úÖ Workflow de recomenda√ß√µes OK');
      return true;
      
    } catch (error) {
      console.error('‚ùå Erro no workflow:', error.message);
      return false;
    }
  }
  
  static async runIntegrationTests() {
    console.log('\nüîß Executando testes de integra√ß√£o - Recommendations...\n');
    
    const workflowTest = await this.testRecommendationWorkflow();
    
    console.log('\nüìä RESULTADOS DA INTEGRA√á√ÉO');
    console.log('============================');
    console.log(`${workflowTest ? '‚úÖ' : '‚ùå'} Workflow de recomenda√ß√µes`);
    
    return { integrationPassed: workflowTest };
  }
}

// Exporta classes de teste
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    TestRecommendations,
    RecommendationsPerformanceTests,
    RecommendationsIntegrationTests
  };
}

// Execu√ß√£o autom√°tica se n√£o estiver sendo importado
if (typeof require !== 'undefined' && require.main === module) {
  (async () => {
    const unitResults = await TestRecommendations.runAllTests();
    const performanceResults = await RecommendationsPerformanceTests.runPerformanceTests();
    const integrationResults = await RecommendationsIntegrationTests.runIntegrationTests();
    
    console.log('\nüéØ RESUMO FINAL - Recommendations Component');
    console.log('==========================================');
    console.log(`Testes unit√°rios: ${unitResults.successRate.toFixed(1)}% de sucesso`);
    console.log(`Performance: ${performanceResults.performancePassed ? 'APROVADA' : 'REPROVADA'}`);
    console.log(`Integra√ß√£o: ${integrationResults.integrationPassed ? 'PASSOU' : 'FALHOU'}`);
    
    const overallSuccess = unitResults.successRate >= 70 && 
                          performanceResults.performancePassed && 
                          integrationResults.integrationPassed;
    
    console.log(`\nStatus geral: ${overallSuccess ? 'üü¢ APROVADO' : 'üî¥ REPROVADO'}\n`);
  })();
}
